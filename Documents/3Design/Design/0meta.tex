\chapter{Design}
META

\section{Components}

We split the project into a number of components based on the requirements, \unsure{ change to this: different iterations of prototypes will be used to test these components?} these components are implemented in different prototype iterations, and thereby tested. 



The features that are planned for the product (using the requirements), are split into components. 

The idea is that the components are mostly separate from each other and each deal with different functionality and concerns. 

Each component is intended to be a complete piece of functionality.

Note that this is not a class diagram over the system architecture that we are going to implement, this follows in section \todo{add ref to class diagram ref{}}. Instead, this component diagram describes only a separation of concerns and dependencies.





\begin{figure}[h]
    \includegraphics[width=\textwidth]{Images/Design/componentDiagram.png}
    \caption{Major components of functionality in the program}
\end{figure}
EXPLAIN ANYTHING THATS STILL UNCLEAR

%Jeg er ikke overbevist om at ovenstående diagram er vildt vigtigt når vi nu alligevel har det nedenstående

\section{Software Architecture}

Diagram over our planned implementation, showing both classes and interfaces
Add function calls to the arrows? Or rather functions to the classes themselves?
This is still not one-to-one with implementation. The API's don't communicate directly with their corresponding sensors, instead they all query the NXT block, which gives access to different functions dependant on which sensors are connected.
Mention external bluetooth-sender program

\begin{figure}[h]
    \includegraphics[width=\textwidth]{Images/Design/architectureClassDiagram.png}
    \caption{Diagram of the program architecture and how these communicate with each other}
\end{figure}

These classes will be used for implementing the program! It is still, however, kind of an abstraction.
In truth, the API's don't communicate directly with their corresponding sensors and actuators (and nxt block). 
Instead, they include libraries that facilitate this communication. 
The figure above shows the implementation of our model, ie. the software of the bus that we write ourselves.

Above this, there are many layers of abstraction in this project before one actually reaches the hardware level of the sensors. These are explained in the following section. 

\section{System Architecture}

Abstraction Layers, OS and nxtOSEK, lejOS?, ref to nxtOSEK section?

ABSTRACTION LAYER DIAGRAM
The frame "Components" in the figure are the components planned in the Software Architecture section. 

The diagram showing layers of abstraction in our design, including our NXTosek operating system

inclue ecrobot\_interface.h in source code
Write about the OSEK standard
And thereby also OIL



%\input{Documents/3Design/Design/1Design}
\input{Documents/3Design/Design/Design_of_track}
\input{Documents/3Design/Design/Design_of_car}