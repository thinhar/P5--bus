\chapter{Design}
Using the data gathered in the previous chapter, we design a product that can solve the requirements at \ref{Requirement}. In this chapter we split the product into modular components that contain its functionality and use this to design the program architecture. Afterwards, we define interfaces to be used for implementing the software of the product. Besides the software, we also decide upon the physical design of the car, including which sensors we will use. Lastly, we will plan how we are going to test whether the individual components of the car conform to the requirements or not.

\section{Components}

We split the project into a number of components based on the requirements, \unsure{ change to this: different iterations of prototypes will be used to test these components?} these components are implemented in different prototype iterations, and thereby tested. 



The features that are planned for the product (using the requirements), are split into components. 

The idea is that the components are mostly separate from each other and each deal with different functionality and concerns. 

Each component is intended to be a complete piece of functionality.

Note that this is not a class diagram over the system architecture that we are going to implement, this follows in section \todo{add ref to class diagram ref{}}. Instead, this component diagram describes only a separation of concerns and dependencies.





\begin{figure}[h]
    \includegraphics[width=\textwidth]{Images/Design/componentDiagram.png}
    \caption{Major components of functionality in the program}
\end{figure}
EXPLAIN ANYTHING THATS STILL UNCLEAR

%Jeg er ikke overbevist om at ovenstående diagram er vildt vigtigt når vi nu alligevel har det nedenstående

\section{Software Architecture}

Diagram over our planned implementation, showing both classes and interfaces
Add function calls to the arrows? Or rather functions to the classes themselves?
This is still not one-to-one with implementation. The API's don't communicate directly with their corresponding sensors, instead they all query the NXT block, which gives access to different functions dependant on which sensors are connected.
Mention external bluetooth-sender program

\begin{figure}[h]
    \includegraphics[width=\textwidth]{Images/Design/architectureClassDiagram.png}
    \caption{Diagram of the program architecture and how these communicate with each other}
    \label{give label}
\end{figure}

These classes will be used for implementing the program! It is still, however, kind of an abstraction.
In truth, the API's don't communicate directly with their corresponding sensors and actuators (and nxt block). 
Instead, they include libraries that facilitate this communication. 
The figure above shows the implementation of our model, ie. the software of the bus that we write ourselves.

Above this, there are many layers of abstraction in this project before one actually reaches the hardware level of the sensors. These are explained in the following section. 

\section{System Architecture}

Abstraction Layers, OS and nxtOSEK, lejOS?, ref to nxtOSEK section?

ABSTRACTION LAYER DIAGRAM
The frame "Components" in the figure are the components planned in the Software Architecture section. 

The diagram showing layers of abstraction in our design, including our NXTosek operating system

inclue ecrobot\_interface.h in source code
Write about the OSEK standard
And thereby also OIL
\begin{figure}[H]
    \includegraphics[width=\textwidth]{Images/Design/abstractionLayerDiagram.png}
    \caption{???}
\end{figure}

Add bluetooth maybe? Probably not, because it's a stub and therefore implementation-specific, not useful for the architecture


The attached ArchitectureClassDiagram describes what we intend for our model implementation. The idea is that we use this diagram directly for our program architecture, so that each object on the diagram becomes a class in the implementation. The light blue coloured API-object are classes that we will create ourselves. The intent with these is that they expose the useful functions that each sensor/actuator has, and also are the place where we calibrate our sensors (so, for instance, we filter out any incorrect measurements).

The attached AbstractionLayerDiagram describes our overall product architecture and abstractions, going from high-level programming to hardware specifics. Our model (eg. everything from the previous diagram) is contained inside the dark blue "Components"-box. The note "coupling to hardware" exists because those are implementation details in nxtOSEK, which we don't really know about.


%\input{Documents/3Design/Design/1Design}
\input{Documents/3Design/Design/Design_of_track}
\input{Documents/3Design/Design/Design_of_car}