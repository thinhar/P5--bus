\section{Theory of Real Time Systems}
In this section the rapport will explain some of the theory behind Real Time Systems. Firstly a brief explanations on some major technical terms used when speaking about real time systems. \unsure{this is meta text to the chapter maybe? RTS shouldn't be a chapter}

Each task has a corresponding period, the period is the interval within which the task should run, determined based on what is required for the task to fulfil its purpose.

A task also has a corresponding deadline, Deadlines are the specific time before which a task should be completed, which will be determined based on what is required for the task to work optimally. A deadline could be the same as the period of the task, however if some task depends on the task, the deadline could be before the period of the task. 

Additionally a task also has a worst case execution time, this defines the maximal time it needs direct control of the CPU to complete its task.

And a task also has a worst case response time, this defines the maximal time from when it is gets released to when it is completed, this is different from the worst case execution time, because this includes the time spent being blocked by higher priority tasks.

A system can be called schedule-able if and only if all of its tasks cant exceed their respective deadlines. This can be calculated by assuming the worst case execution time for all of the tasks, and calculation the worst case response time for all of the tasks. If the worst case response time for all of the tasks doesn't exceed the deadline for all of the tasks, you can call that system schedule-able. 

\todo{text about the different kinds of scheduling}
%\subsection{Cyclic executive scheduling}
%Perhaps the simplest form of scheduling, at least to understand, is Cyclic executive scheduling. Cyclic executive scheduling simply is a list in a never ending while loop. The list is contains all the necessary functions, arranged so that each task executes once in its period. The creation of the list is however a bit harder,   of functions needed to execute the program, this list 

%Event based scheduling

%Fixed priority scheduling 
%Earliest deadline first \unsure{what????}



%Technical terms that should be explained somewhere:

%Schedule-able meaning we can ensure that each task wont exceed their deadline. done

%Period meaning the interval in which a task is required to run once. done 

%Deadline a specific time before which a task should be completed. 

\subsection{\textbf{Fixed-Priority Scheduling}}\label{prioratySch}
Our chosen platform supports two kinds of scheduling directly, Event based scheduling and Fixed-Priority scheduling\cite{OILManual}.

Fixed Priority scheduling works by giving each task a priority, the scheduler will then choice to run the task with the highest priority first. This is simple enough but there are somethings, like how we choose priority of the different tasks,  that must be taken into consideration. It has been proven that giving the tasks priority based on their period and it is not schedule-able then it wont be schedule-able with any other priority. Therefore the choice of priority is trivial, simply found according to the task's relative periods.

There is however also some dangers with this kind of scheduling, namely priority inversion. Priority inversion, exists if there is a task with higher priority waiting for a lower priority task. This can occur if the lower priority grabs a resource, that it cant release until its finished some calculations, that the higher priority also needs. 

We did not want to deal will event based scheduling, because we did not have a clear understanding of how we can ensure "schedule-ability".\todo{this is the reason( selection by elimination), however we cant write this, word it differently or find a better sounding reason}

preemptable task-- a task can be interrupted.
\subsection{\textbf{OSEK Implementation Language}}
In this section the report will go into detail with how the scheduling is supported. Most of the information about this can be found from this source\cite{OILManual}.

OIL stands for OSEK implementation language, it was made as an attempt to create a industry standard for an open-ended architecture for distributed control units in vehicles\cite{OILManual}. It is compiled with the code, and provides some objects or constructions that aim to assist with the scheduling of the code. Since the OIL implementation is quite extensive, this rapport will limit its explanation to what is most relevant for this project. Since the project have decided to use Fixed-Prioraty Scheduling, see \ref{prioratySch}, the report will explain the important constructions in OIL files to support this form of scheduling, the report will therefore explain these three objects in the oil files.

\begin{itemize}
    \item{\textbf{Task}}
    The task in the OIL file is the primitive that the other objects control. The task within the OIL file is directly connected to a task within the c file, which describes the functionality of the task. The task within the OIL file describes the properties of the task. The interesting properties are: \textbf{The schedule value}, this value describes the whether or not the task can be prempted, where FULL corresponds to a premtable task and NON a nonpremtable task. \textbf{AUTO START} unsurprisingly this property determines whether or not the task auto starts. 
    \textbf{Priority} unsurprisingly this attribute describes the priority of a task, the lowest value corresponds to the lowest priority.
    %Random inforamtion:
    %Schedule value: The FULL value of this attribute corresponds to a preemptable task, the NON value to a nonpreemptable task.
    %AUTO START attribute: The AUTOSTART attribute determines whether the task is activated during the system startup procedure or not for some specific application modes. When set to TRUE, a list of application modes is defined in the APPMODE sub-attribute of type APPMODE\_TYPE. These define in which application modes the task is auto-started.
    %PRIORITY: This attribute is of type UINT32.  OSEK OS defines the lowest priority as zero (0); larger values of the PRIORITY attribute correspond to higher priorities.
    \item{\textbf{Counter}}
    A global counter that should be incremented at a fixed interval and is necessary to be able to create a alarm. In the NXT platform, a specific interrupt is used to implement the counter. \todo{maybe more verbose?}
    %Random inforamtion:
    %A COUNTER serves as a base for the ALARM mechanism
    %The counter in NXTOsek can be implemented with a hooking function called "user\_1ms\_isr\_type2" what interrupts every 1 ms, wherein one would count up the counter accordingly\cite{nxtOSEKAPI}.
    \item{\textbf{Alarm}}
    The alarm object controls the tasks, using the counter.  It has the attribute cycle time, which defines the \textbf{period} of a task. 
    
    Random information:
    a Alarm has a reference to a counter
    ACTION attribute: The ACTION attribute defines which type of notification is used when the alarm expires. This attribute is a parameterised ENUM can be used to ACTIVATETASK \{TASK\_TYPE TASK;\}
    AUTOSTART: The AUTOSTART attribute of type BOOLEAN defines if an alarm is started automatically at system start-up depending on the application mode. 
    OTHER:  ALARMTIME, i.e. the time when the ALARM shall expire first, the CYCLETIME, i.e. the cycle time of a cyclic ALARM 
\end{itemize}
%\subsubsection*{\textbf{task}}
%asd
%\subsubsection*{\textbf{Counter}}
%asd
%\subsubsection*{\textbf{Alerm}}
%asd

\subsection{\textbf{Time Constraints}}
Soft Real-time system
\subsection{\textbf{Uppaal}}
We will be using the uppaal tool to model check our schedule to determine whether or not any of the projects tasks can exceed their deadlines.
\subsection{\textbf{Shared Memory}}
 Will be using shared memory since it is faster, simpler. It is more difficult to manage and understand the data locality.
\subsection{\textbf{Shared Resources}} \info{prob not something that should be in to much detail}
 asd




%\subsection{Focus on real-time systems} \todo{This section has been moved and thus the section is not correct anymore. A bit of the section might be salvageable, but much of it will have to be removed or otherwise changed.}
%As written in section \ref{Requirements} the project involves a vehicle, that has to detect and react to the tasks ahead, like detecting bus stops or avoid obstacles, further described in the requirements. In general, the solution will be a control system for the vehicle which has to handle many different tasks. Therefore it is critical that the deadlines for the different functions are met if the actions that the control system takes is to be correct.

%For example, if the obstacle detection system were to miss a deadline, the vehicle could crash and thereby get destroyed, because it did not check if that it was driving into an obstacle.

%Since the control of the vehicle is to be autonomous and the environment can change, the vehicle has to react to the changes in real-time. The control system could, therefore, contain both hard and soft real-time deadlines, the difference is explained in\todo{add ref ref{theory of RTS}}. It is therefore important that a schedule is made to handle the many activities, and ensure that no computations are catastrophic for the control system. 

%It has been decided to focus on real-time systems. The decision of the control system will be hard- or soft real-time systems can be found in section \todo{add ref: ref{SoftwareDesign}}.














